# CodeStyle
Правила написания кода в Strong Editor Team


## Правила классов и структур
> Класс должен отражать сущность, которую он представляет. Имя класса описано существительным.
> Структура содержит однородные данные сущности, либо это простой класс. Имя структуры описано существительным.

### Особенность классов MonoBehaviour
Класс помечается `sealed`, но когда появляется первый наследник, то `sealed` снимается с класса и методы от Unity в базовом классе помечаются как `virtual`

### Именование
- `[name]Controller` - класс контролирует что-то или кого-то внутри себя (PlayerController)
- `[name]Manager` - класс предоставлет публичные методы для управления объектами, которые он содержит (NotifyManager)
- `[name]Helper` - класс для расширение другого класса (TransformHelper)
- возможны и другие наименования

### Структура
блок переменных выглядят так:
* `public поля`
* `public readonly поля`<p>
* `internal поля`
* `internal readonly поля`<p>
* `protected поля`
* `protected readonly поля`<p>
* `private поля`
* `private readonly поля`

Сама структура:<p>
`константы`

`поля с SerializeField`

`блок обычных переменный`

`блок static переменных`

---
`Автоматически реализованные свойства {get; set}`

---
`пустые virtual методы`

`abstract методы`

`abstract свойства`

---
`Сообщения Unity`

`protected\private методы, используемые более 1 раза`

`public методы`

`internal методы`

`скоращённые методы`

---
`Свойства, записанные в одну строчку (get)`

`Свойства с get и set`

## Правила методов
> Метод описывается глаголом.

### Именование
- `Is[name]` - метод с сигнатурой "Это?", возвращает `bool`
- `DoesNeed[name]` - метод с сигнатурой "Нужно ли делать?", возвращает `bool`
- `Can[name]` - метод с сигнатурой "Можно ли?", возвращает `bool`
- `Try[name]` - метод с сигнатурой "Попытаться выполнить", возвращает `bool`: в случае удачного выполнения - `true`, иначе `false`
- `Get[name]` - метод с сигнатурой "Получить", возвращает какой-то объект
- `Set[name]` - метод с сигнатурой "Установить", ничего не возвращает
- `[name]Async` - метод с дополнительной сигнатурой "Выполнить асинхронно"
- возможны и другие наименования

### Сокращение
Если метод выполняет одно действие и его сокращённая запись занимает менее 100 символов, то можно его сократить до длины в одну строчку с помощью `=>`.<p>
Сокращённые методы выносятся в низ класса до свойств

## Правила событий

### события
* Для событий используется ключевое слово `event` и типа делегата. Имя события описывается действием в прошедшем времени (HealthChanged).
* UnityEvent определяются немного по-другому с использованием `on` в начале: `UnityEvent on[EventName]`. Имя события описывается в настоящем простом времени (onClick).
### подписчики C# событий
* Cинтаксис подписчика ваглядит вот так: `On[EventName]`
* Подписка происходит в методах Unity `Awake` или `OnEnable`
* Отписка происходит в методах Unity `OnDestroy` (если подписка была в `Awake`) или `OnDisable` (если подписка была в `OnEnable`)
### подписчики UnityEvent
* Cинтаксис подписчика ваглядит вот так: `Handle[EventName без On]`
* Подписка происходит в методах Unity `Awake` или `OnEnable`
* Отписка происходит в методах Unity `OnDestroy` (если подписка была в `Awake`) или `OnDisable` (если подписка была в `OnEnable`)

## Использование var
> `var` используется в методах и свойствах. Сначала следуйте запретам, а потом уже разрешениям

### когда нельзя использовать
* для переменных численного значения, т.к. не понятен конкретный тип (int, byte, float и т.д.):
  ```C#
  var number = 1; // нельзя! нужно: int number = 1
  ```
* для переменных типа `bool` и `string`, если они были ОДИНОЧНО объявлены:
  ```C#
  var message = "Hello World!";; // нельзя! нужно: string message = "Hello World!";
  ```
  
### когда НУЖНО использовать
* была объявлена переменная и сразу же проинициализирована типом, который выдаёт конструктор:
  ```C#
  var player = new Player();
  ```
* для out параметра в методах с синтаксисом `TryGet[...]<T>` (обратите внимание, что это метод-дженерика):
  ```C#
  bool isHavePlayerComponent = TryGetComponent<Player>(out var player);
  ```
* для получения значения с метода-дженерики:
  ```C#
  var player = GetComponent<Player>();
  ```
### некоторые случаи
* можно использовать `var` для переменных типа `bool` и `string`, если они были объявлены в одном месте с другими `var` переменными:
  ```C#
  var player = new Player();
  var message = "Hello World!";
  var isGame = true;
  ```
  но так нельзя (т.к. приоритет отдаётся классам и структурам, неимеющих литералы):
  ```C#
  Player player = new();
  var message = "Hello World!";
  var isGame = true;
  ```
  правильно:
  ```C#
  Player player = new();
  string message = "Hello World!";
  bool isGame = true;
  ```
* Если в блоке имеются явно определянные переменные, то все переменные в блоке определять с явным типом
  ```C#
  // Здесь нельзя var, т.к. есть явно определянные переменные в этом блоке
  
  AsyncOperation asyncOperator = SceneManager.LoadSceneAsync("sceneName");
  
  string message = "Hello World!";
  bool isGame = true;
  ```
  ```C#
  // Здесь можно var, т.к. нет явно определянных переменных в этом блоке
  
  var asyncOperation = SceneManager.LoadSceneAsync("sceneName");
  asyncOperation.allowSceneActivation = false;
  await WaitLoading(asyncOperation);
  ```
